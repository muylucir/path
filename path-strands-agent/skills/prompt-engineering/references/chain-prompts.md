# Chain Prompts & Reasoning (Multi-turn 프롬프트 & 추론 설계)

복잡한 작업을 여러 턴으로 분해하거나, 단일 턴 내에서 모델의 추론 능력을 극대화하는 기법입니다.

## Chain of Thought (CoT) — 단계적 사고 유도

모델이 바로 답을 출력하지 않고, **단계별로 사고하도록 유도**하여 추론 정확도를 높이는 기법입니다.

### 기본 CoT

```
다음을 단계별로 분석하세요:
1. 먼저 입력 데이터의 핵심 특성을 파악하세요
2. 그 다음 적용 가능한 패턴을 나열하세요
3. 각 옵션의 장단점을 비교하세요
4. 최종적으로 최적 선택과 그 근거를 제시하세요
```

### 구조화된 CoT (XML 태그 활용)

Claude에서 특히 효과적인 방식입니다. 사고 과정과 결과를 태그로 분리합니다.

```xml
<thinking_process>
다음 순서로 분석하세요:
1. <데이터 분석>: 입력 데이터의 핵심 특성 파악
2. <패턴 매칭>: 기존 패턴과 비교
3. <장단점 평가>: 각 옵션의 trade-off 분석
4. <최종 판단>: 최적 옵션 선택 + 근거
</thinking_process>

분석 과정을 <analysis> 태그 안에, 최종 결과를 <result> 태그 안에 작성하세요.
```

→ 모델이 `<analysis>` 안에서 사고하고, `<result>` 안에 결론만 출력하므로 **파싱이 쉬움**

### CoT 적용 가이드

| 태스크 유형 | CoT 필요? | 이유 |
|-----------|:---------:|------|
| 복잡한 분류 (조건 다수) | O | 조건별 체크 과정 필요 |
| 아키텍처 설계 | O | 제약조건 동시 고려 |
| 코드 리뷰 | O | 논리적 정합성 검증 |
| 단순 분류 (카테고리 3-5개) | X | 오버헤드만 증가 |
| 텍스트 추출/변환 | X | 패턴 매칭이므로 사고 불필요 |

### CoT 안티패턴

```
❌ "천천히 생각하세요" → 너무 모호
❌ "단계별로 하세요" (단계 미지정) → 불필요한 단계 생성
✅ 구체적 단계와 각 단계의 목표를 명시
```

## Extended Thinking — Claude 4.x 확장 사고

Claude 4.x 모델의 내장 thinking 모드입니다. 프롬프트 기반 CoT보다 **훨씬 높은 추론 품질**을 제공합니다.

### 프롬프트 CoT vs Extended Thinking

| 항목 | 프롬프트 CoT | Extended Thinking |
|------|:-----------:|:-----------------:|
| **방식** | 프롬프트로 사고 유도 | 모델 내장 thinking 모드 |
| **품질** | 좋음 | 매우 좋음 |
| **비용** | 출력 토큰에 사고 포함 | 별도 thinking 토큰 (할인) |
| **제어** | 사고 구조를 프롬프트로 지정 | budget으로 사고량만 조절 |
| **사고 공개** | 사용자에게 노출됨 | API에서 선택적 공개 |
| **적합 상황** | 가벼운 추론, 사고 과정 표시 | 복잡한 추론, 프로덕션 |

### Extended Thinking 설정 (Bedrock API)

```python
response = client.converse(
    modelId="anthropic.claude-opus-4-6-20250514-v1:0",
    messages=messages,
    inferenceConfig={
        "maxTokens": 16000,
        "thinking": {
            "type": "enabled",
            "budgetTokens": 8000  # 사고에 할당할 토큰 수
        }
    }
)

# 응답에서 thinking과 text 분리
for block in response["output"]["message"]["content"]:
    if block.get("thinking"):
        print("사고 과정:", block["thinking"]["text"])
    elif block.get("text"):
        print("최종 답변:", block["text"])
```

### Budget 가이드

```python
# 태스크 복잡도별 권장 budget
THINKING_BUDGETS = {
    "simple": 2000,     # 간단한 분석 (비교, 선택)
    "moderate": 5000,   # 중간 복잡도 (코드 생성, 패턴 분석)
    "complex": 10000,   # 복잡한 설계 (아키텍처, 멀티 제약조건)
    "maximum": 16000,   # 최대 (연구, 심층 분석)
}
```

### Extended Thinking이 부적합한 경우

- 단순 분류/추출 → 사고 비용 대비 효과 없음
- 짧은 응답 → thinking 토큰 낭비
- 실시간 응답 필요 → 지연 증가
- Streaming 중 thinking 블록 처리 필요

---

## Chain Prompts (Multi-turn 설계)

여러 턴의 대화를 통해 복잡한 작업을 수행하는 프롬프트 설계 전략입니다.

## 체인 유형

### 1. Sequential Chain (순차 체인)

이전 출력이 다음 입력이 되는 구조

```
[Prompt 1] → Output 1 → [Prompt 2 + Output 1] → Output 2 → ...
```

**예시: 콘텐츠 생성 파이프라인**

```
Turn 1 (개요 생성):
"다음 주제에 대한 블로그 글 개요를 작성하세요: [주제]"
→ Output: 개요

Turn 2 (본문 작성):
"다음 개요를 바탕으로 본문을 작성하세요:
[Turn 1 Output]"
→ Output: 본문

Turn 3 (편집):
"다음 글을 검토하고 개선하세요:
[Turn 2 Output]"
→ Output: 최종 글
```

### 2. Refinement Chain (개선 체인)

반복적으로 출력을 개선하는 구조

```
[Generate] → [Critique] → [Refine] → [Critique] → ...
```

**예시: 코드 개선**

```
Turn 1 (초기 생성):
"다음 요구사항에 맞는 함수를 작성하세요: [요구사항]"
→ Output: 초기 코드

Turn 2 (검토):
"다음 코드를 검토하고 문제점을 찾으세요:
[Turn 1 Output]"
→ Output: 문제점 목록

Turn 3 (개선):
"다음 피드백을 반영하여 코드를 개선하세요:
원본 코드: [Turn 1 Output]
피드백: [Turn 2 Output]"
→ Output: 개선된 코드
```

### 3. Branching Chain (분기 체인)

조건에 따라 다른 프롬프트로 분기

```
[Classify] → Category A → [Prompt A]
           → Category B → [Prompt B]
```

**예시: 고객 문의 처리**

```
Turn 1 (분류):
"다음 문의를 분류하세요: [고객 문의]
카테고리: billing, support, sales"
→ Output: {"category": "billing"}

Turn 2a (billing 경로):
"결제 관련 문의입니다. 다음 정보를 확인하세요:
[고객 문의]
필요한 정보: 주문번호, 결제일, 금액"

Turn 2b (support 경로):
"기술 지원 문의입니다. 다음 문제를 진단하세요:
[고객 문의]
확인 사항: 오류 메시지, 발생 시점, 재현 방법"
```

## 컨텍스트 전달 전략

### 명시적 컨텍스트 전달

```
이전 대화:
User: [이전 질문]
Assistant: [이전 답변]

현재 질문: [새 질문]

이전 대화를 참고하여 답변하세요.
```

### 요약 컨텍스트 전달

```
지금까지의 작업 요약:
- 1단계 완료: [요약]
- 2단계 완료: [요약]

다음 단계를 진행하세요: [지시]
```

### 구조화된 상태 전달

```json
{
  "current_step": 3,
  "previous_outputs": {
    "step1": "분석 결과...",
    "step2": "계획..."
  },
  "accumulated_data": {...}
}
```

## Multi-Agent Chain

여러 Agent가 순차적으로 작업하는 체인

```
[Researcher] → 자료 → [Writer] → 초안 → [Editor] → 최종본
```

### 프롬프트 설계

**Researcher Agent:**
```
당신은 리서처입니다.
다음 주제를 조사하고 핵심 정보를 정리하세요: [주제]

출력 형식:
{
  "key_findings": [...],
  "sources": [...],
  "data_points": [...]
}
```

**Writer Agent:**
```
당신은 작가입니다.
다음 조사 결과를 바탕으로 글을 작성하세요:

[Researcher Output]

글 조건:
- 길이: 1000자
- 톤: 전문적
- 구조: 서론-본론-결론
```

**Editor Agent:**
```
당신은 편집자입니다.
다음 글을 검토하고 개선하세요:

[Writer Output]

검토 기준:
- 문법 및 맞춤법
- 논리적 흐름
- 가독성
```

## 체인 종료 조건

### 품질 기반 종료

```
반복 조건:
- 품질 점수가 8/10 이상이면 종료
- 최대 3회 반복

현재 점수: [점수]
반복 횟수: [횟수]

점수가 8 미만이면 다음을 개선하세요: [피드백]
```

### 완료 기반 종료

```
작업 체크리스트:
- [x] 요구사항 분석
- [x] 설계
- [ ] 구현
- [ ] 테스트

다음 미완료 항목을 진행하세요.
모든 항목이 완료되면 "DONE"을 출력하세요.
```

## 오류 처리

### 재시도 프롬프트

```
이전 시도가 실패했습니다.
오류: [오류 메시지]

다음 점을 수정하여 다시 시도하세요:
- [수정 사항 1]
- [수정 사항 2]
```

### 대안 경로

```
[작업]이 불가능한 경우:
1. 먼저 [대안 1]을 시도하세요
2. 그래도 안 되면 [대안 2]를 시도하세요
3. 모두 실패하면 "NEED_HELP"를 반환하세요
```

## 추론 기법 선택 가이드

작업 복잡도에 따라 적절한 추론 기법을 선택하세요:

```
단순 태스크 (분류, 추출)
  → 추론 기법 불필요. 바로 Structured Output으로 결과 강제

중간 태스크 (분석, 코드 생성)
  → 프롬프트 CoT로 사고 유도 + 결과 태그 분리

복잡한 태스크 (아키텍처, 멀티 제약조건)
  → Extended Thinking (budget 8000+) 사용

복잡한 멀티스텝 태스크 (리서치 → 작성 → 검토)
  → Chain Prompts로 단계 분리 + 각 단계에서 CoT/Thinking 선택적 적용
```

## 주의사항

1. **컨텍스트 크기 관리**: 체인이 길어지면 요약 컨텍스트로 압축
2. **오류 전파 방지**: 이전 단계 오류가 전체에 영향 주지 않도록 각 단계에서 검증
3. **명확한 전환**: 각 턴의 역할과 기대 출력을 XML 태그로 명확히 구분
4. **종료 조건**: 무한 루프 방지를 위한 명확한 종료 조건 (품질 점수, 최대 반복 횟수)
5. **비용 최적화**: CoT/Thinking은 필요한 곳에만. 단순 태스크에 적용 시 비용만 증가
6. **Prompt Caching 활용**: 체인의 system prompt 부분은 캐싱하여 비용/지연 절감
